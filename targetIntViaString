using System;
using System.Data;
using System.Xml;
using System.Collections.Generic;
using System.Linq;

/*
Given a string x of digits, 0-9 of length 2 - 10 and an int y that is between -10^4 and 10^4
determine all possible solutions to get y, via inserting the operators
*, +, and/or - into x

e.g. 
string x = "123"
int y = 6

"1+2+3" and "1*2*3" are valid solutions
"1-2*3" is an invalid solution

*/
public class Program
{
	public static void Main()
	{
		string digits = "123"; //0-9 , 2 ≤ digits.length ≤ 10
		int target = 6; // -10^4 ≤ target ≤ 10^4
		List<string> allTestStrings = getAllTestStrings(digits);
		List<string> validExpressions = parseTestStrings(allTestStrings, target);
		Console.WriteLine("Digits = {0}, Target = {1}, validExpressions.Count = {2}", digits, target, validExpressions.Count);
		foreach (string expression in validExpressions)
		{
			Console.WriteLine(expression);
		}
	}

	//given a string "123" return a list of strings containing all possible ints, keeping order
	//e.g. "123","1 23", "12 3", "1 2 3"
	static List<string> getAllTestStrings(string testString)
	{
		List<string> allTestStrings = new List<string>();
		int spaceCount = 1;
		allTestStrings.Add(testString);
		while (spaceCount < testString.Length)
		{
			insertSpaces(testString, spaceCount, 1, ref allTestStrings);
			spaceCount++;
		}

		return allTestStrings;
	}

	static void insertSpaces(string testString, int spaceCount, int index, ref List<string> allTestStrings)
	{
		string workingString = testString;
		for (int i = index; i < testString.Length; i++)
		{
			workingString = testString.Insert(i, " ");
			//insert additional spaces if neccesary
			if (spaceCount > 1)
			{
				spaceCount--;
				//using the newly transformed string, iterate again, passing over the newly added space
				insertSpaces(workingString, spaceCount, i + 2, ref allTestStrings);
			}

			if (!allTestStrings.Contains(workingString))
			{
				allTestStrings.Add(workingString);
			}
		}
	}

	static List<string> parseTestStrings(List<string> allTestStrings, int target)
	{
		List<string> validExpressions = new List<string>();
		//foreach test string
		foreach (string testString in allTestStrings)
		{
			//Console.WriteLine("testString = {0}",testString);
			//split string into int segments
			string[] segments = testString.Split(' ');
			//may not need to cast these strings to ints, I think we convert them to strings again in generateExpressions
			//initialize array to hold ints in testString
			int[] ints = new int[segments.Length];
			//get int[] from testString segments
			for (int i = 0; i < segments.Length; i++)
			{
				ints[i] = int.Parse(segments[i]);
			}

			//generate each test operation
			//Console.WriteLine("foo");
			string[] expressions = generateExpressions(ints);
			//Console.WriteLine("bar");
			//evaluate each test operation
			foreach (string expression in expressions)
			{
				//if test operation resolves to the target, 
				if (validateExpression(expression, target))
				{
					//add operation to final list
					validExpressions.Add(expression);
				}
			}
		}

		return validExpressions;
	}

	static string[] generateExpressions(int[] ints)
	{
		List<string> expressions = new List<string>();
		string[] possibleOperators = getPossibleOperators(ints.Length - 1);
		foreach (string operatorSet in possibleOperators)
		{
			string expression = "";
			//create string alternating between ints[i] and operatorSet[i]
			//e.g. for ints == {1,2} and operatorSet == {+}, expression should resolve to "1+2"
			for (int i = 0; i < ints.Length; i++)
			{
				expression += ints[i];
				if (i < operatorSet.Length)
				{
					expression += operatorSet[i];
				}
			}

			expressions.Add(expression);
		}

		string[] allOperations = expressions.ToArray();
		return allOperations;
	}

	//using operatorCount, create all permutations of operators 
	//e.g. for operatorCount == 1, string[] possibleOperators = new string[]{+, -, *}
	//	   for operatorCount == 2, string[] possibleOperators = new string[]{++, +-, +*,--, -+, -*, **, *-,*+}
	static string[] getPossibleOperators(int operatorCount)
	{
		int maxExpressionCount = (int)Math.Pow(3, operatorCount);
		List<string> operatorSet = new List<string>();
		List<int> operatorsAsInts = new List<int>();
		char[] staticOperators = {'+', '-', '*'};
		//generate operator order
		//given operatorCount x, create int such that int.ToString().Length == x, with each digit == 1
		//e.g. operatorCount == 4, int y == 1111;
		int currentOperator = 1;
		for (int i = currentOperator.ToString().Length; i < operatorCount; i++)
		{
			currentOperator = int.Parse(currentOperator.ToString() + "1");
		}

		if (operatorCount > 0)
		{
			operatorsAsInts.Add(currentOperator);
			//int to array
			int[] workingInts = Array.ConvertAll(operatorsAsInts[0].ToString().ToArray(), x => (int)x - 48);
			//we can then get all permutations of an int with length x, using digits 1,2,3 
			//we will later translate 1 == '+', 2 == '-', 3 == '*'	
			getOperatorPermutations(maxExpressionCount, ref workingInts, ref operatorsAsInts);
		}

		foreach (int temp in operatorsAsInts)
		{
			string trans = temp.ToString().Replace('1', '+').Replace('2', '-').Replace('3', '*');
			operatorSet.Add(trans);
		}

		string[] possibleOperators = operatorSet.ToArray();
		return possibleOperators;
	}

	static bool validateExpression(string expression, int target)
	{
		bool isValid = false;
		DataTable dt = new DataTable();
		int testValue = (int)dt.Compute(expression, "");
		if (testValue == target)
		{
			isValid = true;
		}

		return isValid;
	}

	static int createOperatorSet(int[] workingInts)
	{
		int operatorSet = workingInts[0];
		//append each entry in workingInts to current operator to create the full operatorSet
		for (int i = 1; i < workingInts.Length; i++)
		{
			operatorSet = int.Parse(operatorSet.ToString() + workingInts[i].ToString());
		}

		return operatorSet;
	}

	static void getOperatorPermutations(int maxExpressionCount, ref int[] workingInts, ref List<int> operatorsAsInts)
	{
		int operatorSet;
		operatorSet = createOperatorSet(workingInts);
		//add operatorSet to list
		if (!operatorsAsInts.Contains(operatorSet))
		{
			operatorsAsInts.Add(operatorSet);
		}

		//increase last digit by 1		
		workingInts[workingInts.Length - 1]++;
		//if last digit is out of scope, wrap it to 1.
		if (workingInts[workingInts.Length - 1] > 3)
		{
			workingInts[workingInts.Length - 1] = 1;
		}

		//update operatorSet
		operatorSet = createOperatorSet(workingInts);
		//add operatorSet to list
		if (!operatorsAsInts.Contains(operatorSet))
		{
			operatorsAsInts.Add(operatorSet);
		}

		if (workingInts.Length > 1)
		{
			//shift ints left
			int holder = workingInts[0];
			for (int i = 0; i < workingInts.Length - 1; i++)
			{
				workingInts[i] = workingInts[i + 1];
			}

			//add last digit to operator
			workingInts[workingInts.Length - 1] = holder;
			//update operatorSet
			operatorSet = createOperatorSet(workingInts);
			//add operator to list
			if (!operatorsAsInts.Contains(operatorSet))
			{
				operatorsAsInts.Add(operatorSet);
			}
		}

		if (operatorsAsInts.Count < maxExpressionCount)
		{
			getOperatorPermutations(maxExpressionCount, ref workingInts, ref operatorsAsInts);
		}
	}
}
